CDEmu Daemon
v.1.0.0
~~~~~~~~~~~~~


Table of contents
~~~~~~~~~~~~~~~~~

1. Introduction
2. Userspace-cdemu suite overview
3. Requirements
4. Installation and set-up
5. Troubleshooting
6. CDEmu daemon D-BUS interface
7. Debugging
8. Contact information


1. Introduction
~~~~~~~~~~~~~~~

This is CDEmu daemon, the userspace daemon part of the userspace-cdemu suite, a 
free, GPL CD/DVD-ROM device emulator for linux.

This document describes both the userspace-cdemu suit in general, and the 
specifics of CDEmu daemon, such as installation quirks, troubleshooting, and 
daemon's D-Bus interface.


2. Userspace-cdemu suite overview
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The whole userspace-cdemu suite is intended as a rewrite of cdemu kernel module
and userspace utility that has been written by Robert Penz. But instead of 
providing only block device and linux uniform CD-ROM driver interface, CDEmu 
daemon tries to implement packet command set as specified by MMC-3 and INF-8090,
thus fully emulating an optical storage device.

Main features:
 - full SCSI device emulation: CDEmu daemon attempts to implement MMC-3 packet
     command set, therefore allowing virtual devices to be used not only as 
     block devices, but as full SCSI devices. Aside from mounting the device,
     you can use dd on it, use it with CD-player, or even copy the loaded image
     using one of linux's CD-ROM burning utilities.
 - multiple image format support: userspace-cdemu is based libMirage, an image
     access library, which attempts to provide unified access to various CD-ROM
     image formats (including B6T, CCD, CDI, CUE, ISO, MDS, NRG and TOC)
 - linux HAL support: userspace-cdemu devices are properly detected by HAL, thus
     giving you the same benefits as with the real devices; most notable are
     automount and detection in WINE
 - debugging: both CDEmu daemon and underlying libMirage library have debugging
     code that supports changing verbosity of debug messages while daemon is 
     running, making it easier to discover and fix problems.

The whole userspace-cdemu suite consists of three major components:
 - kernel module
 - userspace daemon
 - userspace clients
 
2.1. Kernel module
~~~~~~~~~~~~~~~~~~

Kernel module takes care of device emulation in the kernel; it registers virtual
device with appripriate drivers and creates corresponding device nodes. It also 
creates a special character device that is used for communication with userspace. 

As device is accessed, requests are generated by kernel, which are in fact SCSI 
commands. These are passed to userspace daemon via afore-mentioned character 
device. Once daemon processes the request, it returns appropriate data and 
status to kernel, thus completing the request.

The whole process is very similar to accessing real device, except that requests
are passed to userspace daemon instead to hardware.

Early, experimental versions of userspace-cdemu used a module that was called
cdemu-module. This release is based on vhba module, which was written by Chia-I 
Wu. Contrary to cdemu-module, which implemented all the interfaces (i.e. block 
device, uniform CD-ROM driver, etc.) manually, vhba implements virtual SCSI host
and lets the kernel's SCSI layer do the rest. This approach is cleaner, faster
and more robust.

2.2. Daemon
~~~~~~~~~~~

This is the part that these docs (should) belong to. The daemon receives SCSI
commands from kernel module and processes them, passing the requested data back
to the kernel. 

Daemon implements the actual virtual device; one instance per each device 
registered by kernel module. It uses libMirage, an image access library that is
part of userspace-cdemu suite, for the image access (e.g. sector reading).

Daemon is controlled through methods that are exposed via D-BUS. It is written
in C and based on GLib (and thus GObjects), but being controlled over D-BUS, it
allows for different clients written in different languages.

2.3. Clients
~~~~~~~~~~~~

Clients are used to control the daemon; examples of the tasks that can be 
achieved by using daemon's D-BUS interface are: loading and unloading a device,
checking device(s) status, setting the debug mask, etc.

A client can be written in any language, as long as it has D-BUS bindings; it can 
be either a CLI or a GUI application. For illustration, two clients are included
as part of userspace-cdemu:
 - cdemu-client: a simple CLI client
 - gcdemu: a GNOME applet
For more information about these particular clients, consult their documentation.

Should you be interested in writing your own client, there is a section in this
document that describes the daemon's interface, methods and signals.


3. Requirements
~~~~~~~~~~~~~~~

CDEmu daemon has the following software requirements:
 - GLib 2.6 or newer
 - D-BUS 0.60 or newer
 - libdaemon 0.10 or newer
 
 - ALSA 1.0.0 or newer (optional audio backend)
 
 - libMirage 1.0.0 or newer (part of the suite)
 - VHBA module (part of the suite)

 
4. Installation and set up
~~~~~~~~~~~~~~~~~~~~~~~~~~

The build and installation process is classical ./configure, make, make install.
However, there are some quirks one should be aware of.


Make sure you have installed all the required libraries; GLib, D-BUS, ALSA and 
libdaemon should be provided by most of the modern distributions and should as
such be detected properly by configure script. 

libMirage, which is also part of userspace-cdemu suite, is also required. If you 
are building and installing it yourself, make sure that its .pc file is visible 
to pkg-config utility; if you are using /usr prefix, you should be fine, but in 
case /usr/local or something else is used and you haven't set up pkg-config to 
look there, you might need to force it to do so.

For example, if libMirage was installed to /usr/local, configure would have to 
be run as "PKG_CONFIG_PATH=/usr/local/lib/pkg-config ./configure".

Vhba module is not a build-time dependency, but it might be a good idea to have 
it installed at this point. 

ALSA audio backend can be disabled with --disable-alsa switch.


The daemon can register its interface on either system or session D-BUS' bus. By 
default, system bus is used. To use session bus, use --bus=session when running daemon. 
If daemon is ran in daemon mode, usage of system bus is automatically implied.

If you wish to run CDEmu daemon on system bus, CDEmu daemon's configuration files
for D-BUS must be installed in appropriate directory. On most systems, this is
/etc/dbus-1/system.d. However, due to the way autotools are used, /etc gets 
prefixed and therefore config file ends up installed into ${prefix}/etc/. To 
avoid this, you should pass --sysconfdir=/etc to configure, regardless of the 
prefix you are passing to configure. Alternatively, you can specify appropriate 
directory using --with-dbus-system-dir switch.

Unlike previous (experimental snapshot) releases, this release of CDEmu daemon
does not provide initscripts. After some thought it was decided it was too much
hassle to write initscripts for different distributions, especially with alternatives
to SysV init system becoming more and more popular. Packagers are welcome to add 
initscripts specific to distribution they are packaging for, of course. Bear in
mind, though, that daemon started by initscripts should be ran in daemon mode
(and therefore use system bus).


5. Troubleshooting (When bad things happen to good people)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Q: I built and installed the module, but I can't insert it ('modprobe vhba' 
results in something along the lines of 'FATAL: Module vhba not found.').

A: Try running 'depmod -a' after you have installed the module.


Q: Daemon fails to start with the following message:
    'cdemud: cdemud_daemon_initialize: failed to open control device /dev/vhba_ctl!
     Daemon initialization failed: Failed to open control device.'

A: The message indicates that either vhba module is not inserted or you don't 
   have read/write permissions for /dev/vhba_ctl. Please make sure that module 
   is inserted, that /dev/vhba_ctl exists and that you have proper read/write 
   permissions.
   
   
Q: Daemon fails to start with the following message:
    'cdemud: cdemud_daemon_initialize: failed to get name on system bus!
     Daemon initialization failed: Name request on D-BUS failed.'

A: The message indicates that name registration on the system bus has failed. 
   The most likely cause of this is improper permissions. Make sure that CDEmu 
   daemon's D-BUS configuration file is in proper place and that you are running 
   the daemon as root.

   
6. CDEmu daemon D-BUS interface (a.k.a. writing your own client)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Communication between CDEmu daemon and a client is done via D-BUS. CDEmu daemon
registers itself on either sytem or session bus, where it exposes the interface 
which can be used by client to control the daemon.

6.1. D-BUS name and object path
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The name CDEmu daemon requests on the system bus is "net.sf.cdemu.CDEMUD_Daemon",
whereas the object path is "/CDEMUD_Daemon". The name of the interface is 
"net.sf.cdemu.CDEMUD_Daemon".

To illustrate, a simple python program connecting to daemon registered on system
bus would therefore look like this:

import dbus
if getattr(dbus, 'version', (0,0,0)) >= (0,41,0):
    import dbus.glib

system_bus = dbus.SystemBus()
dbus_proxy = system_bus.get_object('net.sf.cdemu.CDEMUD_Daemon', '/CDEMUD_Daemon')
dbus_iface = dbus.Interface(dbus_proxy, 'net.sf.cdemu.CDEMUD_Daemon')

6.2. Methods
~~~~~~~~~~~~

For more information on D-BUS methods, argument direction and signatures or 
language-specific data type mappings, please consult the D-BUS documentation.

CDEmu daemon's interface consists of the following methods that can be used to
control the daemon:

* Hail ()
    - This method is intended as a simple means to determine whether
      the daemon is running or not. It succeeds if daemon is running and fails if
      it is not.

* StopDaemon ()
    - As implied in its name, this method stops the daemon. It is
      included for testing purposes only and it should not be used in clients
      (i.e. it can be used to stop daemon that's running in non-daemon mode and
      testing the cleanup routines)

* GetVersion (type, version)
    + type: in; "s"
        String denoting component you are requesting information for; either 
        'daemon' or 'library'.
    + version: out; "s"
        Version string for requested component.
    
    - This method returns version string for the specified component.
    
* GetDeviceDebugMasks (type, masks)
    + type: in; "s"
        String denoting component you are requesting information for; either 
        'daemon' or 'library'.
    + masks: out; "a(si)"
        Array of structures containing supported debug masks. Each structure
        has two fields; debug mask name (string) and debug mask value (int).
        
    - This method returns supported debug masks for the specified component.
   
  
* GetSupportedImageTypes (image_types)
    + image_types: out; "a(sass)"
        Array of structures containing information about supported image types.
        Each structure has three fields; parser ID (string), supported suffixes
        (array of strings) and image description (string).
        
    - This method returns the image types that CDEmu daemon can handle.

* GetNumberOfDevices (number_of_devices)
    + number_of_devices: out; "i"
        Number of devices (int).
    
    - This method returns number of virtual devices.
  
* DeviceGetStatus (device_number, loaded, image_type, file_names)
    + device_number: in; "u"
        Device you are requesting status for (int).
    + loaded: out; "b"
        Boolean denoting whether device is loaded or not.
    + image_type: out; "s"
        Image type (string).
    + file_names: out; "as"
        Image's file name(s) (string).
    
    - This method returns the status for specified device.
  
* DeviceLoad (device_number, file_names)
    + device_number: in; "u"
        Device that is to be loaded (int).
    + file_names: in; "as"
        File name(s) of the image to be loaded (array of strings).
        
    - This method attempts to load the image into device.
    
* DeviceUnload (device_number)
    + device_number: in; "u"
        Device that is to be unloaded (int).
        
    - This method unloads the device.
  
* DeviceGetDebugMask (device_number, type, dbg_mask)
    + device_number: in; "u"
        Device for which debug mask is to be retrieved (int).
    + type: in; "s"
        Component for which debug mask is to be retrieved (string); either
        'daemon' or 'library'.
    + dbg_mask: out; "u"
        Debug mask value (int).
    
    - This method retrieves the debug mask of specified component for specified
      device.
  
* DeviceSetDebugMask (device_number, type, dbg_mask)
    + device_number: in; "u"
        Device for which debug mask is to be set (int).
    + type: in; "s"
        Component for which debug mask is to be set (string); either
        'daemon' or 'library'.
    + dbg_mask: in; "u"
        Debug mask value (int).
    
    - This method sets the debug mask of specified component for specified
      device.

6.3. Signals
~~~~~~~~~~~~

In addition to the methods, CDEmu daemon's interface emits the following signals 
in response to the change of status of either the daemon or one of the devices:

* DaemonChange
    + change_type: "u"
        Change type (int); values are:
        1: daemon has been started
        2: daemon has been stopped
       
* DeviceChange
    + device_number: "u"
        Device that emitted the signal (int).
    + change_type: "u"
        Change type (int); values are:
        1: change of device status (i.e. load/unload)
        2: change of daemon's debug mask for the device
        3: change of library's debug mask for the device
        

7. Debugging
~~~~~~~~~~~~

Both CDEmu daemon and the underlying libMirage contain debugging code that 
supports changing the verbosity of debug traces while the daemon is running
and processing requests. 

The details of changing the debug mask vary from client to client, but in
general it should be possible to change the debug mask of every device for
either the daemon or the library. Supported masks can be obtained from the 
daemon for both components. The actual mask is combination of these masks and
determines which traces get printed and which not.

When daemon is run in non-daemon mode, it prints the traces into console. When
run in daemon mode, system logger (i.e. syslogd) is used.

Using appropriate debug mask and monitoring the output, the source of problem
can be quickly found, be it either a failure in loading an image or incorrect
response to the given command.


8. Contact information
~~~~~~~~~~~~~~~~~~~~~~

CDEmu project's web page: http://cdemu.sourceforge.net
CDEmu project's mailing list: cdemu-devel@lists.sourceforge.net

Author can be directly contacted via e-mail address listed in AUTHORS file.

